#!/usr/bin/env bash

##! name: venv-create
##! desc: Quick virtual environment creator with Python version selector
##! group: python
##! <.ELYX.>

# DEFINE ANSI COLOR CODES

# Standard Text
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
CYAN='\033[36m'
WHITE='\033[37m'

# Bright Text
BRIGHT_RED='\033[91m'
BRIGHT_GREEN='\033[92m'
BRIGHT_YELLOW='\033[93m'
BRIGHT_CYAN='\033[96m'
BRIGHT_MAGENTA='\033[95m'

# Reset
RESET='\033[0m'

# SET PATHS
VENV_DIR="$HOME/pylux-venvs"
CACHE_DIR="$HOME/pylux-cache"
CACHE_REGISTRY="$CACHE_DIR/registry.json"

echo -e "${BRIGHT_MAGENTA}[*] +++ VENV CREATOR +++${RESET}"
echo ""

# GET VENV NAME
echo -e "${CYAN}Where do you want to create the venv?${RESET}"
echo -e "  ${GREEN}1)${RESET} ~/pylux-venvs/ (managed venvs)"
echo -e "  ${GREEN}2)${RESET} Current directory (project venv)"
echo ""
echo -e "${WHITE}Enter choice (1 or 2): ${RESET}"
read -r LOCATION_CHOICE

if [ "$LOCATION_CHOICE" == "1" ]; then
    LOCATION="$VENV_DIR"
    echo ""
    echo -e "${WHITE}Enter venv name: ${RESET}"
    read -r VENV_NAME
    
    if [ -z "$VENV_NAME" ]; then
        echo -e "${BRIGHT_RED}Error: Venv name cannot be empty${RESET}"
        exit 1
    fi
    
    VENV_PATH="$LOCATION/$VENV_NAME"
elif [ "$LOCATION_CHOICE" == "2" ]; then
    echo ""
    echo -e "${WHITE}Enter venv directory name (default: venv): ${RESET}"
    read -r VENV_NAME
    
    VENV_NAME=${VENV_NAME:-venv}
    VENV_PATH="./$VENV_NAME"
else
    echo -e "${BRIGHT_RED}Invalid choice${RESET}"
    exit 1
fi

# CHECK IF ALREADY EXISTS
if [ -d "$VENV_PATH" ]; then
    echo -e "${BRIGHT_RED}Error: Directory $VENV_PATH already exists${RESET}"
    exit 1
fi

echo ""

# GET AVAILABLE PYTHON VERSIONS
echo -e "${CYAN}Available Python versions:${RESET}"

PYTHON_VERSIONS=()
PYTHON_DISPLAY=()
INDEX=1

# Check /usr/local/bin for py* symlinks
for symlink in /usr/local/bin/py[0-9]*; do
    if [ -L "$symlink" ] && [ -x "$symlink" ]; then
        SYMLINK_NAME=$(basename "$symlink")
        VERSION=$("$symlink" --version 2>&1 | awk '{print $2}')
        
        # Mark pre-release versions
        if [[ "$VERSION" =~ (a|b|rc) ]]; then
            echo -e "  ${GREEN}$INDEX)${RESET} $SYMLINK_NAME (Python $VERSION) ${YELLOW}⚠ pre-release${RESET}"
        else
            echo -e "  ${GREEN}$INDEX)${RESET} $SYMLINK_NAME (Python $VERSION)"
        fi
        
        PYTHON_VERSIONS+=("$symlink")
        PYTHON_DISPLAY+=("$VERSION")
        ((INDEX++))
    fi
done

# Also check system python3
if command -v python3 &> /dev/null; then
    SYSTEM_VERSION=$(python3 --version 2>&1 | awk '{print $2}')
    echo -e "  ${GREEN}$INDEX)${RESET} python3 (Python $SYSTEM_VERSION - system)"
    PYTHON_VERSIONS+=("python3")
    PYTHON_DISPLAY+=("$SYSTEM_VERSION")
fi

if [ ${#PYTHON_VERSIONS[@]} -eq 0 ]; then
    echo -e "${BRIGHT_RED}No Python installations found!${RESET}"
    exit 1
fi

echo ""
echo -e "${WHITE}Select Python version (enter number): ${RESET}"
read -r PYTHON_CHOICE

if ! [[ "$PYTHON_CHOICE" =~ ^[0-9]+$ ]] || [ "$PYTHON_CHOICE" -lt 1 ] || [ "$PYTHON_CHOICE" -gt ${#PYTHON_VERSIONS[@]} ]; then
    echo -e "${BRIGHT_RED}Invalid selection${RESET}"
    exit 1
fi

SELECTED_PYTHON="${PYTHON_VERSIONS[$((PYTHON_CHOICE-1))]}"
PYTHON_VERSION="${PYTHON_DISPLAY[$((PYTHON_CHOICE-1))]}"

echo -e "${GREEN}Selected: Python $PYTHON_VERSION${RESET}"
echo ""

# CREATE VENV
echo -e "${GREEN}Creating virtual environment...${RESET}"
"$SELECTED_PYTHON" -m venv "$VENV_PATH"

if [ $? -ne 0 ]; then
    echo -e "${BRIGHT_YELLOW}⚠ Standard venv creation failed, trying without pip...${RESET}"
    "$SELECTED_PYTHON" -m venv --without-pip "$VENV_PATH"
    
    if [ $? -ne 0 ]; then
        echo -e "${BRIGHT_RED}✗ Failed to create venv${RESET}"
        exit 1
    fi
    
    # Manually install pip using get-pip.py
    echo -e "${GREEN}Installing pip manually...${RESET}"
    curl -sS https://bootstrap.pypa.io/get-pip.py | "$VENV_PATH/bin/python"
    
    if [ $? -ne 0 ]; then
        echo -e "${BRIGHT_YELLOW}⚠ Failed to install pip automatically${RESET}"
        echo -e "${YELLOW}You can install it later with:${RESET}"
        echo -e "${WHITE}  curl https://bootstrap.pypa.io/get-pip.py | $VENV_PATH/bin/python${RESET}"
    fi
fi

echo -e "${BRIGHT_GREEN}✓ Virtual environment created successfully!${RESET}"
echo ""

# INITIALIZE CACHE IF NEEDED
if [ ! -d "$CACHE_DIR" ]; then
    mkdir -p "$CACHE_DIR"
    echo '{"cache":{}}' > "$CACHE_REGISTRY"
    echo -e "${GREEN}Initialized package cache at $CACHE_DIR${RESET}"
fi

# VEX GOLD STANDARD: SAFE HARDLINK CACHE WITH PYTHON VERSION ISOLATION
install_with_cache() {
    local package="$1"
    local venv_path="$2"
    local python="$venv_path/bin/python"
    local pip="$venv_path/bin/pip"
    
    # Get Python ABI tag (cp311, cp312, etc.)
    local py_tag=$("$python" -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')" 2>/dev/null)
    
    if [ -z "$py_tag" ]; then
        echo -e "${BRIGHT_RED}    ✗ Failed to detect Python version${RESET}"
        return 1
    fi
    
    # Get site-packages location
    local sitepkgs=$("$python" -c "import site; print(site.getsitepackages()[0])" 2>/dev/null)
    
    if [ -z "$sitepkgs" ]; then
        echo -e "${BRIGHT_RED}    ✗ Failed to locate site-packages${RESET}"
        return 1
    fi
    
    # Create cache directory for this Python version
    mkdir -p "$CACHE_DIR/$py_tag"
    
    echo -e "${CYAN}  Installing $package...${RESET}"
    
    # Install package normally (pip handles all metadata)
    "$pip" install --quiet "$package" 2>/dev/null
    
    if [ $? -ne 0 ]; then
        echo -e "${BRIGHT_YELLOW}    ⚠ Failed to install $package${RESET}"
        return 1
    fi
    
    # Extract package name (strip version specifiers)
    local pkg_name=$(echo "$package" | sed 's/[<>=!~].*//')
    
    # Find the installed package directory (NOT .dist-info)
    local pkg_dir=$(find "$sitepkgs" -mindepth 1 -maxdepth 1 -type d \
        \( -name "${pkg_name}" -o -name "${pkg_name//-/_}" \) \
        ! -name "*.dist-info" ! -name "*.egg-info" \
        2>/dev/null | head -1)
    
    # If no package directory found (e.g., pure metadata packages), that's fine
    if [ -z "$pkg_dir" ]; then
        echo -e "${BRIGHT_GREEN}    ✓ Installed $pkg_name${RESET}"
        return 0
    fi
    
    local pkg_basename=$(basename "$pkg_dir")
    local cache_pkg_dir="$CACHE_DIR/$py_tag/$pkg_basename"
    local tmp_cache="${cache_pkg_dir}.tmp.$$"
    
    # ATOMIC CACHE WRITE: If package not in cache, cache it atomically
    if [ ! -d "$cache_pkg_dir" ]; then
        # Write to temp location first
        mkdir -p "$tmp_cache"
        cp -a "$pkg_dir/" "$tmp_cache/" 2>/dev/null
        
        if [ $? -eq 0 ]; then
            # Atomic move into place
            mv "$tmp_cache" "$cache_pkg_dir" 2>/dev/null
            
            if [ $? -eq 0 ]; then
                echo -e "${BRIGHT_GREEN}    ✓ Cached $pkg_name → $py_tag/$pkg_basename${RESET}"
            else
                rm -rf "$tmp_cache" 2>/dev/null
            fi
        else
            rm -rf "$tmp_cache" 2>/dev/null
        fi
    fi
    
    # SAFE HARDLINK REPLACEMENT: Replace package files with hardlinks to cache
    # Keep .dist-info in venv (pip metadata), hardlink actual package code
    if [ -d "$cache_pkg_dir" ]; then
        rm -rf "$pkg_dir"
        
        # Use cp -al for hardlinks (--reflink=auto if supported for CoW filesystems)
        if cp --help 2>&1 | grep -q reflink; then
            cp -al --reflink=auto "$cache_pkg_dir" "$sitepkgs/" 2>/dev/null
        else
            cp -al "$cache_pkg_dir" "$sitepkgs/" 2>/dev/null
        fi
        
        if [ $? -eq 0 ]; then
            echo -e "${BRIGHT_GREEN}    ✓ Hardlinked $pkg_name from cache (disk space saved!)${RESET}"
        else
            # Fallback: restore from cache without hardlinks
            cp -a "$cache_pkg_dir" "$sitepkgs/" 2>/dev/null
            echo -e "${BRIGHT_YELLOW}    ⚠ Installed $pkg_name (hardlink failed, using copy)${RESET}"
        fi
    else
        echo -e "${BRIGHT_GREEN}    ✓ Installed $pkg_name${RESET}"
    fi
    
    return 0
}

# OFFER TO INSTALL COMMON PACKAGES
echo -e "${YELLOW}Install common packages? (yes/no): ${RESET}"
read -r INSTALL_PACKAGES

if [ "$INSTALL_PACKAGES" == "yes" ] || [ "$INSTALL_PACKAGES" == "y" ]; then
    echo ""
    echo -e "${CYAN}Select package set:${RESET}"
    echo -e "  ${GREEN}1)${RESET} Basic (pip, setuptools, wheel)"
    echo -e "  ${GREEN}2)${RESET} Development (basic + pytest, black, ruff, ipython)"
    echo -e "  ${GREEN}3)${RESET} Web (basic + fastapi, uvicorn, requests, httpx)"
    echo -e "  ${GREEN}4)${RESET} Data Science (basic + numpy, pandas, matplotlib, jupyter)"
    echo -e "  ${GREEN}5)${RESET} Custom (you'll enter packages manually)"
    echo -e "  ${GREEN}6)${RESET} Skip"
    echo ""
    echo -e "${WHITE}Enter choice: ${RESET}"
    read -r PACKAGE_CHOICE
    
    case $PACKAGE_CHOICE in
        1)
            PACKAGES="pip setuptools wheel"
            ;;
        2)
            PACKAGES="pip setuptools wheel pytest black ruff ipython"
            ;;
        3)
            PACKAGES="pip setuptools wheel fastapi uvicorn requests httpx"
            ;;
        4)
            PACKAGES="pip setuptools wheel numpy pandas matplotlib jupyter"
            ;;
        5)
            echo -e "${WHITE}Enter packages (space-separated): ${RESET}"
            read -r PACKAGES
            ;;
        6)
            PACKAGES=""
            ;;
        *)
            echo -e "${BRIGHT_RED}Invalid choice, skipping packages${RESET}"
            PACKAGES=""
            ;;
    esac
    
    if [ -n "$PACKAGES" ]; then
        echo ""
        echo -e "${GREEN}Upgrading pip...${RESET}"
        "$VENV_PATH/bin/pip" install --upgrade pip > /dev/null 2>&1
        
        echo -e "${GREEN}Installing packages with shared cache...${RESET}"
        echo -e "${CYAN}(Using Python version isolation for safety)${RESET}"
        echo ""
        
        # Install each package with cache
        for pkg in $PACKAGES; do
            install_with_cache "$pkg" "$VENV_PATH"
        done
        
        echo ""
        echo -e "${BRIGHT_GREEN}✓ Package installation complete${RESET}"
        
        # Show cache stats
        if [ -d "$CACHE_DIR" ]; then
            CACHE_SIZE=$(du -sh "$CACHE_DIR" 2>/dev/null | awk '{print $1}')
            PY_TAG=$("$VENV_PATH/bin/python" -c "import sys; print(f'cp{sys.version_info.major}{sys.version_info.minor}')" 2>/dev/null)
            if [ -d "$CACHE_DIR/$PY_TAG" ]; then
                CACHED_PKGS=$(find "$CACHE_DIR/$PY_TAG" -mindepth 1 -maxdepth 1 -type d 2>/dev/null | wc -l)
                echo -e "${CYAN}Cache: $CACHE_SIZE ($CACHED_PKGS packages for $PY_TAG)${RESET}"
            else
                echo -e "${CYAN}Cache size: $CACHE_SIZE${RESET}"
            fi
        fi
    fi
fi

echo ""
echo -e "${BRIGHT_GREEN}======================================${RESET}"
echo -e "${BRIGHT_GREEN}✓✓✓ Venv created successfully!${RESET}"
echo -e "${BRIGHT_GREEN}======================================${RESET}"
echo -e "${CYAN}Location: $VENV_PATH${RESET}"
echo -e "${CYAN}Python:   $PYTHON_VERSION${RESET}"
echo ""
echo -e "${BRIGHT_CYAN}Activate with:${RESET}"
if [ "$LOCATION_CHOICE" == "1" ]; then
    echo -e "${WHITE}  source $VENV_PATH/bin/activate${RESET}"
else
    echo -e "${WHITE}  source $VENV_NAME/bin/activate${RESET}"
fi
