#!/usr/bin/env bash

##! name: venv-repair
##! desc: Repair broken virtual environments by recreating them
##! group: python
##! <.ELYX.>

# DEFINE ANSI COLOR CODES

# Standard Text
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
CYAN='\033[36m'
WHITE='\033[37m'

# Bright Text
BRIGHT_RED='\033[91m'
BRIGHT_GREEN='\033[92m'
BRIGHT_YELLOW='\033[93m'
BRIGHT_CYAN='\033[96m'
BRIGHT_MAGENTA='\033[95m'

# Reset
RESET='\033[0m'

# SET PATHS
VENV_DIR="$HOME/venvs"

echo -e "${BRIGHT_MAGENTA}[*] +++ VENV REPAIR WIZARD +++${RESET}"
echo ""

# CHECK IF VENV DIRECTORY EXISTS
if [ ! -d "$VENV_DIR" ]; then
    echo -e "${BRIGHT_RED}No venv directory found at $VENV_DIR${RESET}"
    exit 1
fi

# FIND ALL BROKEN VENVS
echo -e "${CYAN}Scanning for broken virtual environments...${RESET}"
echo ""

BROKEN_VENVS=()

for venv_path in "$VENV_DIR"/*/; do
    if [ -d "$venv_path" ]; then
        VENV_NAME=$(basename "$venv_path")
        PYTHON_BIN="$venv_path/bin/python"
        ACTIVATE_SCRIPT="$venv_path/bin/activate"
        
        # Check if it's broken (missing python or activate)
        if [ ! -f "$ACTIVATE_SCRIPT" ] || [ ! -f "$PYTHON_BIN" ]; then
            BROKEN_VENVS+=("$VENV_NAME")
        fi
    fi
done

if [ ${#BROKEN_VENVS[@]} -eq 0 ]; then
    echo -e "${BRIGHT_GREEN}No broken virtual environments found!${RESET}"
    exit 0
fi

echo -e "${YELLOW}Found ${#BROKEN_VENVS[@]} broken virtual environment(s):${RESET}"
for venv in "${BROKEN_VENVS[@]}"; do
    echo -e "  ${RED}✗${RESET} $venv"
done
echo ""

# ASK WHICH VENV TO REPAIR
echo -e "${CYAN}Which venv would you like to repair?${RESET}"
echo -e "${WHITE}Enter the venv name (or 'all' to repair all, 'exit' to quit): ${RESET}"
read -r SELECTED_VENV

if [ "$SELECTED_VENV" == "exit" ]; then
    echo -e "${YELLOW}Exiting...${RESET}"
    exit 0
fi

# PREPARE LIST OF VENVS TO REPAIR
VENVS_TO_REPAIR=()

if [ "$SELECTED_VENV" == "all" ]; then
    VENVS_TO_REPAIR=("${BROKEN_VENVS[@]}")
else
    # Check if the selected venv is in the broken list
    if [[ " ${BROKEN_VENVS[@]} " =~ " ${SELECTED_VENV} " ]]; then
        VENVS_TO_REPAIR=("$SELECTED_VENV")
    else
        echo -e "${BRIGHT_RED}Error: '$SELECTED_VENV' is not in the list of broken venvs${RESET}"
        exit 1
    fi
fi

# GET AVAILABLE PYTHON VERSIONS
echo ""
echo -e "${CYAN}Available Python versions:${RESET}"

PYTHON_VERSIONS=()
PYTHON_DISPLAY=()
INDEX=1

# Check /usr/local/bin for py* symlinks
for symlink in /usr/local/bin/py[0-9]*; do
    if [ -L "$symlink" ] && [ -x "$symlink" ]; then
        SYMLINK_NAME=$(basename "$symlink")
        VERSION=$("$symlink" --version 2>&1 | awk '{print $2}')
        echo -e "  ${GREEN}$INDEX)${RESET} $SYMLINK_NAME (Python $VERSION)"
        PYTHON_VERSIONS+=("$symlink")
        PYTHON_DISPLAY+=("$VERSION")
        ((INDEX++))
    fi
done

# Also check system python3
if command -v python3 &> /dev/null; then
    SYSTEM_VERSION=$(python3 --version 2>&1 | awk '{print $2}')
    echo -e "  ${GREEN}$INDEX)${RESET} python3 (Python $SYSTEM_VERSION - system)"
    PYTHON_VERSIONS+=("python3")
    PYTHON_DISPLAY+=("$SYSTEM_VERSION")
fi

if [ ${#PYTHON_VERSIONS[@]} -eq 0 ]; then
    echo -e "${BRIGHT_RED}No Python installations found!${RESET}"
    exit 1
fi

echo ""

# REPAIR EACH VENV
for venv_name in "${VENVS_TO_REPAIR[@]}"; do
    VENV_PATH="$VENV_DIR/$venv_name"
    
    echo -e "${BRIGHT_CYAN}======================================${RESET}"
    echo -e "${BRIGHT_CYAN}Repairing: $venv_name${RESET}"
    echo -e "${BRIGHT_CYAN}======================================${RESET}"
    
    # TRY TO EXTRACT PACKAGE LIST BEFORE DESTROYING
    REQUIREMENTS_FILE="/tmp/venv_repair_${venv_name}_requirements.txt"
    OLD_PYTHON_VERSION=""
    
    echo -e "${YELLOW}Attempting to extract package list...${RESET}"
    
    # Method 1: Try pip freeze if possible
    EXTRACTED=false
    if [ -f "$VENV_PATH/bin/pip" ]; then
        "$VENV_PATH/bin/pip" freeze > "$REQUIREMENTS_FILE" 2>/dev/null
        if [ $? -eq 0 ] && [ -s "$REQUIREMENTS_FILE" ]; then
            PACKAGE_COUNT=$(wc -l < "$REQUIREMENTS_FILE")
            echo -e "${GREEN}✓ Extracted $PACKAGE_COUNT packages via pip freeze${RESET}"
            EXTRACTED=true
        fi
    fi
    
    # Method 2: Extract from lib/pythonX.X/site-packages/*.dist-info
    if [ "$EXTRACTED" = false ]; then
        echo -e "${YELLOW}Trying to extract from site-packages directory...${RESET}"
        
        # Find the python version directory
        LIB_DIR="$VENV_PATH/lib"
        if [ -d "$LIB_DIR" ]; then
            PYTHON_LIB_DIR=$(find "$LIB_DIR" -maxdepth 1 -type d -name "python*" | head -n 1)
            
            if [ -n "$PYTHON_LIB_DIR" ]; then
                OLD_PYTHON_VERSION=$(basename "$PYTHON_LIB_DIR" | sed 's/python//')
                SITE_PACKAGES="$PYTHON_LIB_DIR/site-packages"
                
                echo -e "${CYAN}  Found old venv used: Python $OLD_PYTHON_VERSION${RESET}"
                
                if [ -d "$SITE_PACKAGES" ]; then
                    # Extract package names from .dist-info directories
                    find "$SITE_PACKAGES" -maxdepth 1 -type d -name "*.dist-info" -exec basename {} \; | \
                        sed 's/-[0-9].*//' | \
                        grep -v "^pip$" | \
                        grep -v "^setuptools$" | \
                        sort -u > "$REQUIREMENTS_FILE"
                    
                    if [ -s "$REQUIREMENTS_FILE" ]; then
                        PACKAGE_COUNT=$(wc -l < "$REQUIREMENTS_FILE")
                        echo -e "${GREEN}✓ Extracted $PACKAGE_COUNT packages from site-packages${RESET}"
                        EXTRACTED=true
                    fi
                fi
            fi
        fi
    fi
    
    if [ "$EXTRACTED" = false ]; then
        rm -f "$REQUIREMENTS_FILE"
        echo -e "${YELLOW}⚠ No packages found, will create fresh venv${RESET}"
    fi
    
    echo ""
    
    # CHOOSE PYTHON VERSION FOR THIS VENV
    SELECTED_PYTHON=""
    
    if [ -n "$OLD_PYTHON_VERSION" ]; then
        # Try to find matching Python version
        MATCHED_INDEX=-1
        for i in "${!PYTHON_DISPLAY[@]}"; do
            # Check if version matches (e.g., 3.12.* matches 3.12)
            if [[ "${PYTHON_DISPLAY[$i]}" == "$OLD_PYTHON_VERSION"* ]]; then
                MATCHED_INDEX=$i
                break
            fi
        done
        
        echo -e "${CYAN}Original venv used Python $OLD_PYTHON_VERSION${RESET}"
        echo ""
        echo -e "${YELLOW}Choose repair mode:${RESET}"
        echo -e "  ${GREEN}1)${RESET} Recreate with same version (Python $OLD_PYTHON_VERSION)"
        echo -e "  ${GREEN}2)${RESET} Upgrade to different Python version"
        echo ""
        echo -e "${WHITE}Enter choice (1 or 2): ${RESET}"
        read -r REPAIR_MODE
        
        if [ "$REPAIR_MODE" == "1" ]; then
            if [ $MATCHED_INDEX -ge 0 ]; then
                SELECTED_PYTHON="${PYTHON_VERSIONS[$MATCHED_INDEX]}"
                echo -e "${GREEN}Using matched Python ${PYTHON_DISPLAY[$MATCHED_INDEX]}${RESET}"
            else
                echo -e "${BRIGHT_YELLOW}Warning: Python $OLD_PYTHON_VERSION not found!${RESET}"
                echo -e "${YELLOW}Available Python versions:${RESET}"
                for i in "${!PYTHON_VERSIONS[@]}"; do
                    echo -e "  ${GREEN}$((i+1)))${RESET} Python ${PYTHON_DISPLAY[$i]}"
                done
                echo ""
                echo -e "${WHITE}Select Python version (enter number): ${RESET}"
                read -r PYTHON_CHOICE
                
                if ! [[ "$PYTHON_CHOICE" =~ ^[0-9]+$ ]] || [ "$PYTHON_CHOICE" -lt 1 ] || [ "$PYTHON_CHOICE" -gt ${#PYTHON_VERSIONS[@]} ]; then
                    echo -e "${BRIGHT_RED}Invalid selection, skipping $venv_name${RESET}"
                    continue
                fi
                
                SELECTED_PYTHON="${PYTHON_VERSIONS[$((PYTHON_CHOICE-1))]}"
            fi
        else
            echo -e "${YELLOW}Available Python versions:${RESET}"
            for i in "${!PYTHON_VERSIONS[@]}"; do
                echo -e "  ${GREEN}$((i+1)))${RESET} Python ${PYTHON_DISPLAY[$i]}"
            done
            echo ""
            echo -e "${WHITE}Select Python version (enter number): ${RESET}"
            read -r PYTHON_CHOICE
            
            if ! [[ "$PYTHON_CHOICE" =~ ^[0-9]+$ ]] || [ "$PYTHON_CHOICE" -lt 1 ] || [ "$PYTHON_CHOICE" -gt ${#PYTHON_VERSIONS[@]} ]; then
                echo -e "${BRIGHT_RED}Invalid selection, skipping $venv_name${RESET}"
                continue
            fi
            
            SELECTED_PYTHON="${PYTHON_VERSIONS[$((PYTHON_CHOICE-1))]}"
        fi
    else
        # No old version detected, just ask for Python version
        echo -e "${YELLOW}Available Python versions:${RESET}"
        for i in "${!PYTHON_VERSIONS[@]}"; do
            echo -e "  ${GREEN}$((i+1)))${RESET} Python ${PYTHON_DISPLAY[$i]}"
        done
        echo ""
        echo -e "${WHITE}Select Python version (enter number): ${RESET}"
        read -r PYTHON_CHOICE
        
        if ! [[ "$PYTHON_CHOICE" =~ ^[0-9]+$ ]] || [ "$PYTHON_CHOICE" -lt 1 ] || [ "$PYTHON_CHOICE" -gt ${#PYTHON_VERSIONS[@]} ]; then
            echo -e "${BRIGHT_RED}Invalid selection, skipping $venv_name${RESET}"
            continue
        fi
        
        SELECTED_PYTHON="${PYTHON_VERSIONS[$((PYTHON_CHOICE-1))]}"
    fi
    
    PYTHON_VERSION=$("$SELECTED_PYTHON" --version 2>&1 | awk '{print $2}')
    echo -e "${BRIGHT_GREEN}Selected: Python $PYTHON_VERSION${RESET}"
    echo ""
    
    # BACKUP AND REMOVE OLD VENV
    echo -e "${YELLOW}Removing broken venv...${RESET}"
    BACKUP_PATH="${VENV_PATH}.backup.$(date +%s)"
    mv "$VENV_PATH" "$BACKUP_PATH"
    
    if [ $? -ne 0 ]; then
        echo -e "${BRIGHT_RED}✗ Failed to backup old venv${RESET}"
        continue
    fi
    
    echo -e "${GREEN}✓ Old venv backed up to: $BACKUP_PATH${RESET}"
    
    # CREATE NEW VENV
    echo -e "${GREEN}Creating new venv with Python $PYTHON_VERSION...${RESET}"
    "$SELECTED_PYTHON" -m venv "$VENV_PATH"
    
    if [ $? -ne 0 ]; then
        echo -e "${BRIGHT_RED}✗ Failed to create new venv${RESET}"
        echo -e "${YELLOW}Restoring backup...${RESET}"
        mv "$BACKUP_PATH" "$VENV_PATH"
        continue
    fi
    
    echo -e "${GREEN}✓ New venv created${RESET}"
    
    # RESTORE PACKAGES IF WE HAVE THEM
    if [ -f "$REQUIREMENTS_FILE" ]; then
        echo -e "${GREEN}Restoring packages...${RESET}"
        "$VENV_PATH/bin/pip" install --upgrade pip > /dev/null 2>&1
        "$VENV_PATH/bin/pip" install -r "$REQUIREMENTS_FILE"
        
        if [ $? -eq 0 ]; then
            echo -e "${BRIGHT_GREEN}✓ Packages restored successfully${RESET}"
        else
            echo -e "${BRIGHT_YELLOW}⚠ Some packages may have failed to install${RESET}"
        fi
        
        rm -f "$REQUIREMENTS_FILE"
    fi
    
    # ASK ABOUT REMOVING BACKUP
    echo ""
    echo -e "${YELLOW}Delete backup at $BACKUP_PATH? (yes/no): ${RESET}"
    read -r DELETE_BACKUP
    
    if [ "$DELETE_BACKUP" == "yes" ] || [ "$DELETE_BACKUP" == "y" ]; then
        rm -rf "$BACKUP_PATH"
        echo -e "${GREEN}✓ Backup deleted${RESET}"
    else
        echo -e "${YELLOW}Backup kept at: $BACKUP_PATH${RESET}"
    fi
    
    echo -e "${BRIGHT_GREEN}✓✓✓ $venv_name repaired successfully!${RESET}"
    echo ""
done

echo -e "${BRIGHT_GREEN}======================================${RESET}"
echo -e "${BRIGHT_GREEN}Repair complete!${RESET}"
echo -e "${BRIGHT_GREEN}======================================${RESET}"
echo -e "${CYAN}Run 'venv-list' to see your repaired environments${RESET}"
